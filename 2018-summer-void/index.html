<!DOCTYPE html>
<html>
  <head>
    <title>Void</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      img {
        max-width: 100%;
        max-height: 100%;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">
class: center, middle

## 区块链中的分布式系统挑战
by jiangplus

---
# about me

 * imtoken

 * ipfs/dat

 * kubernetes

 * void : 一个基于 git 数据结构的侧链和去中心数据库

---

### 区块链

 * 一个分布式数字账本

 * 通过非对称加密密钥数字签名发起交易

 * 交易由矿工打包成区块，全网广播，可验证可追溯

 * 每个区块包含上一个区块的 hash，并附上工作量证明，形成链式结构，最长的链条（也是难度最大的）成为唯一的共识

 * 加密算法，p2p，共识机制，可验证数据结构

 * 安全，性能，去中心


---

### 工作量证明 Proof of Work

 * 加密哈希函数是不可逆的单向函数（md5，sha1，sha2，sha3）

 * 对给定区块要求 sha3（header + nonce）有尽可能多前置的 “0”

 * 为了满足难度要求，只能穷举 nonce 进行暴力破解

 * 指数复杂性的计算量，极易验证

 * 在每一个区块时间内，首先到达难度要求（指定的 0 足够多）的区块，会被广播到网络

 * 后续的区块会基于前面的区块，总是会有短暂的分叉，链沿着难度最大的方向增长，算力即共识

 * 无需其他先验知识即可验证账本有效性，不需要中央权威背书的去中心账本


---

### UTXO

![utxo](en-tx-overview.svg)

---

### 对工作量证明的攻击

 * 如果一个节点拥有超过 50% 的算力，能够保证持续达到难度要求，即可控制链的走向

 * 通过生成新的分叉，排除某些交易，可以修改自己的交易记录，double spend attack

 * 无法修改其他人的交易记录，无法凭空产生比特币


 * 随着网络不断扩大，全网算力不断增加，要达到过半的算力是经济上困难的

 * 算力以矿池的形式不断集中，几个最大的矿池联合起来有可能达到 51% 的算力

 * 大型矿池的一小部分算力即可攻击一些较为弱小的链（并且已经发生）

---

### 对工作量证明的攻击

 * selfish mining attack 可以在 33% 算力下获得更大挖矿权

 * 当矿工成功挖到区块时，不马上广播，而是立即挖下一个区块

 * 无法 double spend，但弱化了网络的安全性，制造了分配的不公平


---

### 对抗 ASIC 的哈希设计

 
 * 矿池使用专门的 ASIC 芯片计算哈希难题，更高的计算密集度和更高的能效
 
 * 为对抗 ASIC 矿机对算力的垄断，设计内存消耗型的 hash 模型
 
 * Ethereum 的 Ethash，Zcash 基于广义生日悖论问题的 Equihash，aeternity 基于二分图环路检测的 Cuckoo Cycle
 
 * 专用硬件在内存芯片上较难取得优势，通常使用 GPU 挖矿，保护一般用户的参与权

---

### PoW 的问题

 
 * 消耗大量能源做无用功
 
 * 矿工利益与链上代币持有者的利益不一致，阻碍区块链的技术升级
 
 * 无法惩罚作恶者，只能剥夺恶意矿工的收益
 
 * 新的区块链无法获得足够的算力保障安全性
 
 * 由于矿池的垄断性，更容易中心化

---

### Proof of Stake 权益证明

 
 * 由 PeerCoin 首创，节点获得区块创建权的概率取决于该节点在系统中所占有的权益比例的大小
 
 * 由于一般持有代币的用户不一定由能力参与挖矿，产生 DPoS（Delegated Proof of Stake），由用户根据权益份额投票选出代理节点，进行挖矿，在代理节点中形成共识
 
 * 相当于股份制的权益机制和代议制民主的治理结构
 
 * 保障安全性、降低中心化风险以及提升能源效率

---

### PoS 的安全性

 
 * 用户参与网络治理不需要矿机等专门的设备，可以更好行使权益，权益和权利的均等
 
 * 可以实现多种博弈机制，避免 selfish mining attack
 
 * 要求矿工存入一定的代币押金，对作恶的节点进行经济惩罚，作恶是负收益，导致更高的代价
 
 * 可以引入投票治理机制，促进网络的持续升级进化

---

### 两种 PoS

 * chain-based proof of stake

 每个时间段随机选择矿工赋予挖矿权，新的区块必须在之前最长链之后，最长链成为共识

 * BFT-style proof of stake

 每一轮随机选择一个矿工赋予挖矿权，但区块的确认需要所有矿工的投票确认，对链的共识可以仅限于这个区块本身，跟链的长度无关

---

### EOS 的设计


 * 通过代币持有者的投票产生 126 个矿工节点委托进行挖矿，每 6 个区块的每一轮需要 21 个矿工

 * 每个区块取得当前一轮矿工 2/3 的票数，即可确认

 * 因为参与节点数量少，准入门槛高，要求带宽和计算能力高，区块可以非常大，产生更大的吞吐量，接近一个分布式数据库

 * 采用 C++ 开发，WebAssembly 合约语言，主观的计时机制


 * 声势浩大，利益关系复杂的节点竞选，最终网络控制器集中在少数节点上，不够去中心化

 * 对节点性能要求非常严苛，进入门槛高

 * 矿工容易共谋，干扰网络正常运行

 * 容易面临监管和 DDoS 攻击

 * 矿工节点被入侵对网络影响比较大

---

### Casper


 * 以太坊官方提出的 PoS 方案，未来将采用 PoW 和 PoS 的混合机制

 * 每个 PoS 矿工需要质押代币六个月，如果被发现违规行为，将被处罚，即负激励机制

 * 每 100 个区块一个 checkpoint，在此需要超过 2/3 的节点投票

 * 每个 checkpoint 是不可逆的，一旦投票通过即认为区块有效

 * 对于长程攻击，引入了弱主观性

 * 如果网络发生分区，部分节点无效，会逐步降低总的权益池的大小，让网络恢复可用性

 * 矿工群体可以是动态的

 * 可以结合 sharding，分成多个矿工池，并行出块

---

### 性能问题

 * 所有交易上链，每个节点需要存储全部历史

 * 为保障区块在有效时间内广播，区块体积不能太大，比特币为 1M，10 minutes

 * 每一个时间间隔只有一个有效区块，无法并行

 * 交易数据，智能合约代码，附加数据都占据了体积

---

### State Channel


 * 区块大小本身是瓶颈，把所有交易写入区块制约了吞吐量

 * 交易双方把钱存入私有的状态通道，进行高频次的小额交易，不需要与主链发生联系，让交易发生在链外

 * 任何一方都可以随时退出，只有最后的状态是有效的，最后通过更新主链的状态清算

 * 安全性由主链保证，隐私性较好，惩罚作弊方，同时需要监听通道的状态

 * 可以极大提高吞吐能力，但有一些限制条件

---

### 侧链


 * 让链衍生多个子链，变成并行的多链结构

 * 每条侧链有自己的矿工，独立出块或者通过 BFT 投票出块

 * 子链的哈希状态定期写入主链，得到全网公正和全局共识，惩罚作恶的子链矿工

 * 需要解决治理机制，数据可用性问题，子链间交互问题

 * Telegram，Quarkchain 等

---

### DAG


 * 完全摒弃区块打包形式和线性的链式结构，网状结构的交易连接，高吞吐量

 * 每个交易自动加入，自动被其他交易引用，当满足足够 PoS 或 PoW 的时候自动生效

 * 最终一致模型，网络稳定性存疑

 * 不同节点会看到不同的世界视图，很难设计智能合约

 * ByteBall，IOTA，Hashgraph


---

### MerkleTree

![tree](tree.webp)

---

### MerkleTree


Merkle Tree 是利用 Hash 对内容的正确性进行快速鉴定的数据结构


 * Merkle Tree 父节点包含所有子节点的 Hash 值；

 * Merkle Tree 的 Tree 可以是任何形式的 Tree ，任何经典的 tree 构造算法都可以经过简单的修改应用到 Merkle Tree 上；

 * Merkle Tree 通常只在 Leaf Node 上存储数据；

 * Merkle Tree 对单个数据的校验最多需要 O(h) 时间，其中 h 为树高，如果树足够平衡，则验证单个节点的复杂度为 O(log⁡(n)).

 * 作用：验证局部数据是全局数据的一部分

---

### SPV


 * 在 BitCoin 中，Merkle Tree 主要用来实现轻节点，

 * 轻节点只存 Top Hash，当轻节点要验证一笔交易时（如 L4），则向存有全部数据的完全节点验证

 * 全节点将 L4 到 root 的路径上的所有 node（1-1，1-0，1，0，Top Hash）,轻节点对根据这条路径计算得到 Top Hash，如果计算得到的 Top Hash 与本地的 Top Hash 相等，则轻节点就可以相信完全节点传过来的数据。

 * 只要少量的元数据就可以验证某一笔交易是否已经花费掉，以及是否同步到链的最长状态

---

### Plasma

以太坊创始人提出来的侧链模型，结合 SPV 和状态通道


 * 矿工维护一条轻量级的侧链，质押一定代币

 * 用户在主链上把钱转入侧链的合约

 * 用户以 UTXO 的形式进行高频交易，由侧链矿工打包进入侧链

 * 侧链定期把 MerkleTree 的根写入主链

 * 用户需要从侧链转出余额，提交要提取的 UTXO 和对应的 MerkleTree Proof，证明此交易是当前主链历史状态的一部分，此提取会被冻结一段时间

 * 为了避免有新的交易花掉这笔 UTXO，其他发现该用户作弊的人可以提交新的 UTXO 证明这一笔金额已经被花掉，同时获得举报的奖励金

 * 过了挑战期，用户提交的 UTXO 没有有效的挑战，可以取走这笔交易的余额

更加简单，高效，合约友好，同时可伸缩性好

---

### 交易的并行性

* 目前区块链总的吞吐量比较小，网络是主要瓶颈，计算非常富余

* 当吞吐量提高，在有限的出块时间计算智能合约就会成为瓶颈


* 比特币的交易采用 UTXO 的机制，记录每一笔资产的流向，UTXO 之间可以高度并行

* 以太坊采用 account 模型，记录如 +10，-5，+20 这样的变更事件，便于智能合约的实现，但因为无法知道一笔依赖哪些账号和资源，所以无法并行处理同一个区块的交易

* 新型区块链的合约设计，通常采用函数式设计，或要求声明交易的依赖，使同一区块的交易可以在多核并行


---

### Web3


  * Web 3.0 的图景

  * 计算，存储，通讯

  * 可以类比为去中心的云计算平台，一个开放的，永久的，不断进化的网络框架

---

### IPFS 和 Filecoin


  * 去中心的 S3

  * content address

  * 开放的 p2p 存储市场和 CDN 市场

  * 如何证明

  * 通过贡献存储来挖矿，得到区块生成权和代币

---

### 多方安全计算


  * 一个开放共享的分布式数据库

  * 一个具有前所未有的安全机制的全局账本

  * 可验证，可追溯，可审计，加密安全设计

  * 没有中央控制，依靠社区共识

  * 基于分布式系统和算法的合作机制

  * trustless trustful


    </textarea>
    <script src="./remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
